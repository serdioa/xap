/*
 * Copyright (c) 2008-2016, GigaSpaces Technologies, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Generated By:JavaCC: Do not edit this line. SqlParser.java */
package com.j_spaces.jdbc.parser.grammar;

import com.j_spaces.core.client.TemplateMatchCodes;
import com.j_spaces.jdbc.AbstractDMLQuery;
import com.j_spaces.jdbc.AlterTableQuery;
import com.j_spaces.jdbc.CommitQuery;
import com.j_spaces.jdbc.CreateTableQuery;
import com.j_spaces.jdbc.DeleteQuery;
import com.j_spaces.jdbc.DropTableQuery;
import com.j_spaces.jdbc.InsertQuery;
import com.j_spaces.jdbc.OrderColumn;
import com.j_spaces.jdbc.ProcedureQuery;
import com.j_spaces.jdbc.Query;
import com.j_spaces.jdbc.QueryProcessor;
import com.j_spaces.jdbc.SelectColumn;
import com.j_spaces.jdbc.SelectQuery;
import com.j_spaces.jdbc.SqlConstants;
import com.j_spaces.jdbc.UpdateColumn;
import com.j_spaces.jdbc.UpdateQuery;
import com.j_spaces.jdbc.driver.Blob;
import com.j_spaces.jdbc.driver.Clob;
import com.j_spaces.jdbc.parser.AndNode;
import com.j_spaces.jdbc.parser.ColumnNode;
import com.j_spaces.jdbc.parser.ContainsItemNode;
import com.j_spaces.jdbc.parser.ContainsItemsRootNode;
import com.j_spaces.jdbc.parser.ContainsNode;
import com.j_spaces.jdbc.parser.EqualNode;
import com.j_spaces.jdbc.parser.ExpNode;
import com.j_spaces.jdbc.parser.GTENode;
import com.j_spaces.jdbc.parser.GTNode;
import com.j_spaces.jdbc.parser.InNode;
import com.j_spaces.jdbc.parser.InnerQueryNode;
import com.j_spaces.jdbc.parser.IsNullNode;
import com.j_spaces.jdbc.parser.LTENode;
import com.j_spaces.jdbc.parser.LTNode;
import com.j_spaces.jdbc.parser.LikeNode;
import com.j_spaces.jdbc.parser.LiteralNode;
import com.j_spaces.jdbc.parser.NotEqualNode;
import com.j_spaces.jdbc.parser.NotInNode;
import com.j_spaces.jdbc.parser.NotLikeNode;
import com.j_spaces.jdbc.parser.OrNode;
import com.j_spaces.jdbc.parser.PreparedNode;
import com.j_spaces.jdbc.parser.RLikeNode;
import com.j_spaces.jdbc.parser.RelationNode;
import com.j_spaces.jdbc.parser.RowNumNode;
import com.j_spaces.jdbc.parser.ValueNode;

import java.io.Reader;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashSet;
import java.util.Iterator;

public class SqlParser implements SqlParserConstants {

    private int conditionIndex = 0;

        // TOKEN_EXTENDS=com.j_spaces.jdbc.parser.SerializableToken
    public static void main(String[] args) throws ParseException {
        SqlParser parser = new SqlParser(System.in);
        while(true) {
            try {

                Query query = parser.parseStatement();
                System.out.println("Query received and parsed: " );
                System.out.println(query);
            }catch (Exception e)
            {
                System.err.println("Caught Exception - error in query");
                e.printStackTrace();
                parser.ReInit(System.in);
                System.exit(-1);
            }
        }
    }

    public void reset(Reader reader)
        {
                conditionIndex=0;
                ReInit(reader);
        }

// start statement methods
  final public Query parseStatement() throws ParseException {
  Query query;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      query = selectSql();
      break;
    case DELETE:
      query = deleteSql();
      break;
    case INSERT:
      query = insertSql();
      break;
    case UPDATE:
      query = updateSql();
      break;
    case CREATE:
      query = createTable();
      break;
    case DROP:
      query = dropTable();
      break;
    case ALTER:
      query = alterTable();
      break;
    case COMMIT:
    case ROLLBACK:
      query = commit();
      break;
    case CALL:
      query = executeProcedure();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

/* statement methods */
  final public Query selectSql() throws ParseException {
  SelectQuery query;
  ExpNode exp = null;
    jj_consume_token(SELECT);
                query = new SelectQuery();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
    case DISTINCT:
      setQuantifier(query);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    selectColumnList(query);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLOSEPAREN:
      jj_consume_token(CLOSEPAREN);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(FROM);
    selectTableList(query);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      exp = SqlExpression(query);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP:
      groupBy(query);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      orderBy(query);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR_UPDATE:
      jj_consume_token(FOR_UPDATE);
                         query.setForUpdate(true);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
        query.setExpTree(exp);
        {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

// handle SQLQuery syntax (no from clause)
  final public AbstractDMLQuery readMultipleQuery() throws ParseException {
   AbstractDMLQuery query;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CALL:
      query = executeProcedure();
      break;
    default:
      jj_la1[9] = jj_gen;
      query = selectSqlQuery();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

// handle SQLQuery syntax (no from clause)
  final public SelectQuery selectSqlQuery() throws ParseException {
    SelectQuery query = new SelectQuery();

    ExpNode exp = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
    case OPENPAREN:
      exp = SqlExpression(query);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP:
      groupBy(query);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      orderBy(query);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR_UPDATE:
      jj_consume_token(FOR_UPDATE);
                         query.setForUpdate(true);
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
        SelectColumn selectC = new SelectColumn("*");
        query.addColumn(selectC);

        query.setExpTree(exp);
        {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

// handle SQLQuery syntax (no from clause)
  final public DeleteQuery deleteSqlQuery() throws ParseException {
        DeleteQuery query = new DeleteQuery();
        ExpNode exp = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
    case OPENPAREN:
      exp = SqlExpression(query);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        query.setExpTree(exp);
        {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

// handle SQLQuery syntax (no from clause)
  final public SelectQuery countSqlQuery() throws ParseException {
    SelectQuery query = new SelectQuery();
    ExpNode exp = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
    case OPENPAREN:
      exp = SqlExpression(query);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP:
      groupBy(query);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER:
      orderBy(query);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR_UPDATE:
      jj_consume_token(FOR_UPDATE);
                         query.setForUpdate(true);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        SelectColumn selectC = new SelectColumn("*");
        selectC.setCount(true);
        selectC.setFunctionName(SqlConstants.COUNT);
        query.setAggFunction(true);
        query.addColumn(selectC);

        query.setExpTree(exp);
        {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query deleteSql() throws ParseException {
        DeleteQuery query;
        ExpNode exp = null;
    jj_consume_token(DELETE);
                query = new DeleteQuery();
    jj_consume_token(FROM);
    tableNameWithOptionalAlias(query);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      exp = SqlExpression(query);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
        query.setExpTree(exp);
        {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query updateSql() throws ParseException {
        UpdateQuery query;
        ExpNode exp = null;
    jj_consume_token(UPDATE);
                query = new UpdateQuery();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BY:
      jj_consume_token(BY);
      jj_consume_token(UID);
                       query.setByUid(true);
      break;
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      tableNameWithOptionalAlias(query);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(SET);
    columnListWithValues(query);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      exp = SqlExpression(query);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
        query.setExpTree(exp);
        {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query insertSql() throws ParseException {
  InsertQuery query;
  Query innerQuery = null;
    jj_consume_token(INSERT);
                query = new InsertQuery();
    jj_consume_token(INTO);
    tableName(query);
    if (jj_2_1(2)) {
      jj_consume_token(OPENPAREN);
      columnList(query);
      jj_consume_token(CLOSEPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUES:
      jj_consume_token(VALUES);
      jj_consume_token(OPENPAREN);
      insertValuesList(query);
      jj_consume_token(CLOSEPAREN);
      break;
    case SELECT:
    case OPENPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        jj_consume_token(OPENPAREN);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      innerQuery = selectSql();
                                                   query.setQuery((SelectQuery)innerQuery);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLOSEPAREN:
        jj_consume_token(CLOSEPAREN);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query createTable() throws ParseException {
  CreateTableQuery query;
  Token column, PKName;
  String table,type;
  ArrayList columns;
  ArrayList types;
  ArrayList indices;
  int index = 0;
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
                          query = new CreateTableQuery();
    table = className();
                              query.setTableName(table);
                                                  columns = new ArrayList();
                                                  types = new ArrayList();
                                                  indices = new ArrayList();
    jj_consume_token(OPENPAREN);
    column = id();
                                                                String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                                                                                                                  column.image.toUpperCase();
                                                                columns.add(columnName);
    type = sqlType();
                                                   types.add(type);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDEX:
    case PRIMARY_KEY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMARY_KEY:
        jj_consume_token(PRIMARY_KEY);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NOT:
          jj_consume_token(NOT);
          jj_consume_token(NULL);
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
        break;
      case INDEX:
        jj_consume_token(INDEX);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                                                     indices.add(new Integer(index));
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFAULT_NULL:
      jj_consume_token(DEFAULT_NULL);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_1;
      }
      jj_consume_token(125);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMARY_KEY:
        jj_consume_token(PRIMARY_KEY);
        jj_consume_token(OPENPAREN);
        PKName = id();
                                                for (int i=0; i<columns.size(); i++) {
                                                                                        if (PKName.image.equalsIgnoreCase((String)(columns.get(i)))) {
                                                                                                indices.add(new Integer(i));
                                                                                                break;
                                                                                        }
                                                                                }
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 125:
            ;
            break;
          default:
            jj_la1[33] = jj_gen;
            break label_2;
          }
          jj_consume_token(125);
          PKName = id();
                                            for (int i=0; i<columns.size(); i++) {
                                                                                        if (PKName.image.equalsIgnoreCase((String)(columns.get(i)))) {
                                                                                                indices.add(new Integer(i));
                                                                                                break;
                                                                                        }
                                                                                }
        }
        jj_consume_token(CLOSEPAREN);
        break;
      case PARTITION_BY:
        jj_consume_token(PARTITION_BY);
        jj_consume_token(OPENPAREN);
        column = id();
                                                        if (query.getRoutingFieldName() != null)
                                                                {if (true) throw new ParseException("PARTITION BY can only be set for one column!");}
                                                        columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                                                                  column.image.toUpperCase();
                                                        query.setRoutingFieldName(columnName);
        jj_consume_token(CLOSEPAREN);
        break;
      case IDENTIFIER:
      case ESC_IDENTIFIER:
        column = id();
                                                                columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                                                                                                                  column.image.toUpperCase();
                                                                columns.add(columnName);
        type = sqlType();
                                                   types.add(type); index++;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INDEX:
        case PRIMARY_KEY:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PRIMARY_KEY:
            jj_consume_token(PRIMARY_KEY);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case NOT:
              jj_consume_token(NOT);
              jj_consume_token(NULL);
              break;
            default:
              jj_la1[34] = jj_gen;
              ;
            }
            break;
          case INDEX:
            jj_consume_token(INDEX);
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                                                                                              indices.add(new Integer(index));
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFAULT_NULL:
          jj_consume_token(DEFAULT_NULL);
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(CLOSEPAREN);
         String[] namesArray = new String[columns.size()];
         String[] typesArray = new String[types.size()];
         boolean[] indicesArray = new boolean[types.size()];
     Iterator it = indices.iterator();
     while (it.hasNext()) {
        indicesArray[((Integer)it.next()).intValue()] = true;
     }
         query.setColumnNames((String[])columns.toArray(namesArray));
         query.setColumnTypes((String[])types.toArray(typesArray));
         query.setIndices(indicesArray);
         {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query dropTable() throws ParseException {
  DropTableQuery query;
  String table;
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
                        query = new DropTableQuery();
    table = className();
                query.setTableName(table);
                {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query alterTable() throws ParseException {
  AlterTableQuery query;
  Token index;
  String table;
  ArrayList columns;
    jj_consume_token(ALTER);
    jj_consume_token(TABLE);
                         query = new AlterTableQuery();
    table = className();
                             query.setTableName(table);
    jj_consume_token(ADD);
    jj_consume_token(PRIMARY_KEY);
    jj_consume_token(OPENPAREN);
                                         columns = new ArrayList();
    index = id();
                       String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? index.image :
                                                                                                                  index.image.toUpperCase();
                                                        columns.add(columnName);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_3;
      }
      jj_consume_token(125);
      index = id();
                            columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? index.image :
                                                                                                                  index.image.toUpperCase();
                                                                columns.add(columnName);
    }
    jj_consume_token(CLOSEPAREN);
    jj_consume_token(USING);
    jj_consume_token(INDEX);
          String[] names = new String[columns.size()];
          query.setIndices((String[])columns.toArray(names));
          {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public Query commit() throws ParseException {
  CommitQuery query;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMIT:
      jj_consume_token(COMMIT);
                    query = new CommitQuery(true);
      break;
    case ROLLBACK:
      jj_consume_token(ROLLBACK);
                       query = new CommitQuery(false);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

  final public ProcedureQuery executeProcedure() throws ParseException {
  ProcedureQuery query=null;
  Token  procedure, parameter;
  String negative = "";
  ArrayList parmList =  new ArrayList();;
    jj_consume_token(CALL);
               query = new ProcedureQuery();
    procedure = id();
                      String procName = procedure.image;
                             query.setProcName(procName);
    jj_consume_token(OPENPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case ESC_IDENTIFIER:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case QUESTIONMARK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        parameter = jj_consume_token(STRING_LITERAL);
                                    String parameterName = parameter.image;
                                   query.addParamList(parameterName);
        break;
      case INTEGER_LITERAL:
        parameter = jj_consume_token(INTEGER_LITERAL);
                                      query.addParamList(new Integer(parameter.image));
        break;
      case LONG_LITERAL:
        parameter = jj_consume_token(LONG_LITERAL);
                                   query.addParamList(new Long(parameter.image.substring(0,parameter.image.length()-1)));
        break;
      case FLOATING_POINT_LITERAL:
        parameter = jj_consume_token(FLOATING_POINT_LITERAL);
                                             query.addParamList(new Float(parameter.image));
                                                                                                negative="";
        break;
      case IDENTIFIER:
      case ESC_IDENTIFIER:
        parameter = id();
                       query.addParamList(procedure.image);
        break;
      case QUESTIONMARK:
        parameter = jj_consume_token(QUESTIONMARK);
                                   query.setPrepared(true); query.addParamList(null); ++conditionIndex;
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 125:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_4;
        }
        jj_consume_token(125);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          parameter = jj_consume_token(STRING_LITERAL);
                                         String parameterName = parameter.image;
                                   query.addParamList(parameterName);
          break;
        case INTEGER_LITERAL:
          parameter = jj_consume_token(INTEGER_LITERAL);
                                      query.addParamList(new Integer(parameter.image)); negative="";
          break;
        case LONG_LITERAL:
          parameter = jj_consume_token(LONG_LITERAL);
                                    query.addParamList(new Long(parameter.image.substring(0,parameter.image.length()-1)));
          break;
        case FLOATING_POINT_LITERAL:
          parameter = jj_consume_token(FLOATING_POINT_LITERAL);
                                             query.addParamList(new Float(parameter.image)); negative="";
          break;
        case IDENTIFIER:
        case ESC_IDENTIFIER:
          parameter = id();
                       query.addParamList(procedure.image);
          break;
        case QUESTIONMARK:
          parameter = jj_consume_token(QUESTIONMARK);
                                    query.setPrepared(true); query.addParamList(null); ++conditionIndex;
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    jj_consume_token(CLOSEPAREN);
      {if (true) return query;}
    throw new Error("Missing return statement in function");
  }

/* specific clause methods */

//check for the distinct
  final public void setQuantifier(SelectQuery query) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTINCT:
      jj_consume_token(DISTINCT);
                   query.setDistinct(true);
      break;
    case ALL:
      jj_consume_token(ALL);
                   query.setDistinct(false);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//retrieve a list of columns that are seperated by a comma
  final public void columnList(AbstractDMLQuery query) throws ParseException {
  Token column = null;
    column = id();
                       String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                                                                                                                  column.image.toUpperCase();
                                                        query.addColumn(columnName);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_5;
      }
      jj_consume_token(125);
      column = id();
                            columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image :
                                                                                                                  column.image.toUpperCase();
                                                                query.addColumn(columnName);
    }
  }

//retrieve a list of columns that are seperated by a comma for a select Query
  final public void selectColumnList(SelectQuery query) throws ParseException {
  Token column = null;
  Token value = null;
  SelectColumn selectC = null;
    if (jj_2_2(2)) {
      id();
      jj_consume_token(DOT);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UID:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
    case STRING_LITERAL:
    case ASTERISK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case ESC_IDENTIFIER:
        selectC = getSelectColumn(query);
        break;
      case ASTERISK:
        jj_consume_token(ASTERISK);
                       selectC = new SelectColumn("*");
        break;
      case UID:
        jj_consume_token(UID);
                  selectC = new SelectColumn("UID");
        break;
      case STRING_LITERAL:
        value = jj_consume_token(STRING_LITERAL);
        selectC = getSelectColumn(query);
                                                                          selectC.setValue(value.image);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
           if ( selectC != null) {
                     query.addColumn(selectC);
                  }
      break;
    default:
      jj_la1[48] = jj_gen;
      if (jj_2_3(2)) {
        function((SelectQuery)query);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_6;
      }
      jj_consume_token(125);
      if (jj_2_4(2)) {
        id();
        jj_consume_token(DOT);
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UID:
      case IDENTIFIER:
      case ESC_IDENTIFIER:
      case STRING_LITERAL:
      case ASTERISK:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
        case ESC_IDENTIFIER:
          selectC = getSelectColumn(query);
          break;
        case ASTERISK:
          jj_consume_token(ASTERISK);
                            selectC = new SelectColumn("*");
          break;
        case UID:
          jj_consume_token(UID);
                       selectC = new SelectColumn("UID");
          break;
        case STRING_LITERAL:
          value = jj_consume_token(STRING_LITERAL);
          selectC = getSelectColumn(query);
                                                                          selectC.setValue(value.image);
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
               if ( selectC != null) {
                     query.addColumn(selectC);
                   }
        break;
      default:
        jj_la1[51] = jj_gen;
        if (jj_2_5(2)) {
          function((SelectQuery)query);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
            query.addAbsentCol();
  }

  final public void columnListWithValues(UpdateQuery query) throws ParseException {
  ArrayList<LiteralNode> newValues = new ArrayList<LiteralNode>();
    setColumnValue(query, newValues);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_7;
      }
      jj_consume_token(125);
      setColumnValue(query, newValues);
    }
        query.setUpdatedValues(newValues);
  }

  final public void setColumnValue(UpdateQuery updateQuery, ArrayList<LiteralNode> newValues) throws ParseException {
  Token column, newValue ;
  String negative = "";
  UpdateColumn updateColumn = null;
  Token selfIncrementedColumn;
    column = id();
                        String columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? column.image : column.image.toUpperCase();
                        updateColumn = new UpdateColumn(columnName);
                        updateQuery.addUpdateColumn(updateColumn);
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
      jj_consume_token(MINUS);
                         negative="-";
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTIONMARK:
      newValue = jj_consume_token(QUESTIONMARK);
                                 updateQuery.setPrepared(true); newValues.add(new PreparedNode(null)); ++conditionIndex;
      break;
    case STRING_LITERAL:
      newValue = jj_consume_token(STRING_LITERAL);
                                    newValues.add(new LiteralNode(newValue.image.substring(1,newValue.image.length()-1)));
      break;
    case INTEGER_LITERAL:
      newValue = jj_consume_token(INTEGER_LITERAL);
                                     newValues.add(new LiteralNode(negative + newValue.image));
      break;
    case LONG_LITERAL:
      newValue = jj_consume_token(LONG_LITERAL);
                                  newValues.add(new LiteralNode(negative + newValue.image.substring(0,newValue.image.length()-1)));
      break;
    case FLOATING_POINT_LITERAL:
      newValue = jj_consume_token(FLOATING_POINT_LITERAL);
                                            newValues.add(new LiteralNode(negative + newValue.image));
      break;
    case TRUE:
      jj_consume_token(TRUE);
                                  newValues.add(new LiteralNode(Boolean.TRUE));
      break;
    case FALSE:
      jj_consume_token(FALSE);
                                  newValues.add(new LiteralNode(Boolean.FALSE));
      break;
    case EMPTY_CLOB:
      jj_consume_token(EMPTY_CLOB);
                                     newValues.add(new LiteralNode(new Clob("")));
      break;
    case EMPTY_BLOB:
      jj_consume_token(EMPTY_BLOB);
                                     newValues.add(new LiteralNode(new Blob(new byte[0])));
      break;
    case NULL:
      jj_consume_token(NULL);
                                            newValues.add(new LiteralNode(null));
      break;
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      selfIncrementedColumn = id();
                    columnName = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ?
                        selfIncrementedColumn.image : selfIncrementedColumn.image.toUpperCase();
                        updateColumn.setSelfIncrementedColumnName(columnName);
                        updateQuery.setSelfIncrementedUpdateColumn(true);
      jj_consume_token(PLUS);
      newValue = jj_consume_token(INTEGER_LITERAL);
                                                      newValues.add(new LiteralNode(negative + newValue.image));
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void function(SelectQuery query) throws ParseException {
 Token token = null;
 SelectColumn selectC = null;
 String alias = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUM:
      jj_consume_token(SUM);
                 selectC = new SelectColumn(); selectC.setSum(true);selectC.setFunctionName(SqlConstants.SUM); query.setAggFunction(true);
      break;
    case COUNT:
      jj_consume_token(COUNT);
                   selectC = new SelectColumn(); selectC.setCount(true);selectC.setFunctionName(SqlConstants.COUNT); query.setAggFunction(true);
      break;
    case MAX:
      jj_consume_token(MAX);
                 selectC = new SelectColumn(); selectC.setFunctionName(SqlConstants.MAX); query.setAggFunction(true);
      break;
    case MIN:
      jj_consume_token(MIN);
                 selectC = new SelectColumn(); selectC.setFunctionName(SqlConstants.MIN); query.setAggFunction(true);
      break;
    case AVG:
      jj_consume_token(AVG);
                 selectC = new SelectColumn(); selectC.setFunctionName(SqlConstants.AVG); query.setAggFunction(true);
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(OPENPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
                             selectC.setName("*"); query.addColumn(selectC);
      break;
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      token = id();
            String id = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? token.image : token.image.toUpperCase();

                        selectC.setName(id);
                        query.addColumn(selectC);
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CLOSEPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      token = id();
                                 selectC.setAlias(token.image);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
  }

/*

ColumnNode createColumnNode(AbstractDMLQuery query,String columnFunc):
{
 String table = null;
 String columnName = null;
 ColumnNode columnNode = null;
 Token t, function = null;
 }
 {
    LOOKAHEAD(2) function = <IDENTIFIER> <OPENPAREN> t = id()  <CLOSEPAREN> {
        String id =  (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
        columnNode = new ColumnNode(id);
        columnNode.setFunctionName(function.image);
        return columnNode;
    }
 	|(t = id() {
    	 String id =  (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
    	 columnNode = new ColumnNode(id);
    })

    {return columnNode;}
}

*/
  final public ColumnNode createColumnNode(AbstractDMLQuery query,String columnFunc) throws ParseException {
 String table = null;
 String columnName = null;
 ColumnNode columnNode = null;
 Token t, function = null;
 java.util.List params;
    if (jj_2_6(2)) {
      function = jj_consume_token(IDENTIFIER);
      jj_consume_token(OPENPAREN);
      params = createFunctionParams();
      jj_consume_token(CLOSEPAREN);
        java.util.List args = new java.util.ArrayList();
        int pos = 0;
        int columnIndex = 0;
        for(Object p : params){
            if(p instanceof ColumnNode){
               if(columnNode == null){
                   args.add(null);
                   columnNode = (ColumnNode)p;
                   columnIndex = pos;
               }else{
                   {if (true) throw new ParseException("More then one column in function call " + function.image + " call " + columnNode + " " + p);}
               }
            }else{
                args.add(p);
            }
            pos += 1;
        }
        if(columnNode == null){
            {if (true) throw new ParseException("Missing column in function call " + function.image);}
        }
        columnNode.setFunctionCallDescription(new com.j_spaces.jdbc.builder.range.FunctionCallDescription(function.image, columnIndex, args));
        {if (true) return columnNode;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case ESC_IDENTIFIER:
        t = id();
         String id =  (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
         columnNode = new ColumnNode(id);
     {if (true) return columnNode;}
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public java.util.List createFunctionParams() throws ParseException {
    java.util.List params = new java.util.ArrayList();
    Object param;
    param = param();
        params.add(param);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_8;
      }
      jj_consume_token(125);
      param = param();
        params.add(param);
    }
       {if (true) return params;}
    throw new Error("Missing return statement in function");
  }

  final public Object param() throws ParseException {
  Token parameter;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      parameter = jj_consume_token(STRING_LITERAL);
                                   {if (true) return new String(parameter.image.substring(1, parameter.image.length() - 1));}
      break;
    case INTEGER_LITERAL:
      parameter = jj_consume_token(INTEGER_LITERAL);
                                       {if (true) return new Integer(parameter.image);}
      break;
    case LONG_LITERAL:
      parameter = jj_consume_token(LONG_LITERAL);
                                    {if (true) return new Long(parameter.image.substring(0, parameter.image.length() - 1));}
      break;
    case FLOATING_POINT_LITERAL:
      parameter = jj_consume_token(FLOATING_POINT_LITERAL);
                                              {if (true) return (new Float(parameter.image));}
      break;
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      parameter = id();
                          String id =  (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? parameter.image : parameter.image.toUpperCase();
                          {if (true) return new ColumnNode(id);}
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//retrieve a list of tables in a select query
  final public void selectTableList(SelectQuery query) throws ParseException {
  String table = null;
  Token alias = null;
    table = className();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      alias = id();
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
     query.addTableWithAlias(table, ((alias == null) ? null : alias.image)); alias = null;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_9;
      }
      jj_consume_token(125);
      table = className();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case ESC_IDENTIFIER:
        alias = id();
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
     query.addTableWithAlias(table, ((alias == null) ? null : alias.image)); alias = null;
    }
  }

  final public void tableNameWithOptionalAlias(AbstractDMLQuery query) throws ParseException {
  String tableName = null; Token tableAlias = null;
    tableName = className();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      tableAlias = id();
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
          query.addTableWithAlias(tableName, ((tableAlias == null)? null : tableAlias.image));
  }

  final public void tableName(AbstractDMLQuery query) throws ParseException {
  String table = null;
    table = className();
     query.setTableName(table);
  }

  final public void insertValuesList(InsertQuery insertQuery) throws ParseException {
  Token t = null;
String negative = "";
ArrayList<LiteralNode> list = new ArrayList<LiteralNode>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTIONMARK:
      t = jj_consume_token(QUESTIONMARK);
                              insertQuery.setPrepared(true); list.add(new PreparedNode(null));
      break;
    case TRUE:
      jj_consume_token(TRUE);
                                    list.add(new LiteralNode(Boolean.TRUE));
      break;
    case FALSE:
      jj_consume_token(FALSE);
                                    list.add(new LiteralNode(Boolean.FALSE));
      break;
    case NULL:
      jj_consume_token(NULL);
                                                    list.add(new LiteralNode(null));
      break;
    case EMPTY_CLOB:
      jj_consume_token(EMPTY_CLOB);
                                     list.add(new LiteralNode(new Clob("")));
      break;
    case EMPTY_BLOB:
      jj_consume_token(EMPTY_BLOB);
                                     list.add(new LiteralNode(new Blob(new byte[0])));
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                             list.add(new LiteralNode(new String(t.image.substring(1,t.image.length()-1))));
      break;
    default:
      jj_la1[69] = jj_gen;
      if (jj_2_7(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
        }
        t = jj_consume_token(INTEGER_LITERAL);
                                                                       list.add(new LiteralNode(negative + t.image));
      } else if (jj_2_8(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[67] = jj_gen;
          ;
        }
        t = jj_consume_token(LONG_LITERAL);
                                                                    list.add(new LiteralNode(negative + t.image.substring(0,t.image.length()-1)));
      } else if (jj_2_9(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                              list.add(new LiteralNode(negative + t.image));
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                                                                                                                                 negative="";
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[70] = jj_gen;
        break label_10;
      }
      jj_consume_token(125);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUESTIONMARK:
        t = jj_consume_token(QUESTIONMARK);
                               insertQuery.setPrepared(true); list.add(new PreparedNode(null));
        break;
      case TRUE:
        jj_consume_token(TRUE);
                                  list.add(new LiteralNode(Boolean.TRUE));
        break;
      case FALSE:
        jj_consume_token(FALSE);
                                  list.add(new LiteralNode(Boolean.FALSE));
        break;
      case NULL:
        jj_consume_token(NULL);
                                                  list.add(new LiteralNode(null));
        break;
      case EMPTY_CLOB:
        jj_consume_token(EMPTY_CLOB);
                                     list.add(new LiteralNode(new Clob("")));
        break;
      case EMPTY_BLOB:
        jj_consume_token(EMPTY_BLOB);
                                     list.add(new LiteralNode(new Blob(new byte[0])));
        break;
      case STRING_LITERAL:
        t = jj_consume_token(STRING_LITERAL);
                             list.add(new LiteralNode(new String(t.image.substring(1,t.image.length()-1))));
        break;
      default:
        jj_la1[74] = jj_gen;
        if (jj_2_10(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            jj_consume_token(MINUS);
                             negative = "-";
            break;
          default:
            jj_la1[71] = jj_gen;
            ;
          }
          t = jj_consume_token(INTEGER_LITERAL);
                                                                       list.add(new LiteralNode(negative + t.image));
        } else if (jj_2_11(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            jj_consume_token(MINUS);
                             negative = "-";
            break;
          default:
            jj_la1[72] = jj_gen;
            ;
          }
          t = jj_consume_token(LONG_LITERAL);
                                                                    list.add(new LiteralNode(negative + t.image.substring(0,t.image.length()-1)));
        } else if (jj_2_12(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            jj_consume_token(MINUS);
                             negative = "-";
            break;
          default:
            jj_la1[73] = jj_gen;
            ;
          }
          t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                              list.add(new LiteralNode(negative + t.image));
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
       negative="";
    }
     insertQuery.setValues(list);
  }

  final public void groupBy(SelectQuery query) throws ParseException {
 SelectColumn groupColumn = null;
 ArrayList list = new ArrayList();
    jj_consume_token(GROUP);
    jj_consume_token(BY);
    groupColumn = getSelectColumn(query);
                                                        list.add(groupColumn);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_11;
      }
      jj_consume_token(125);
      groupColumn = getSelectColumn(query);
                                                        list.add(groupColumn);
    }
   query.setGroupColumn(list);
  }

  final public void orderBy(SelectQuery query) throws ParseException {
 Token column = null;
 OrderColumn orderColumn = null;
 ArrayList list = new ArrayList();
    jj_consume_token(ORDER);
    jj_consume_token(BY);
    orderColumn = createOrderColumn(query);
                        list.add(orderColumn);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
    case DESC:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
        jj_consume_token(ASC);
                     orderColumn.setDesc(false);
        break;
      case DESC:
        jj_consume_token(DESC);
                                                            orderColumn.setDesc(true);
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[77] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULLS_LAST:
    case NULLS_FIRST:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULLS_LAST:
        jj_consume_token(NULLS_LAST);
                          orderColumn.setNullsLast(true);
        break;
      case NULLS_FIRST:
        jj_consume_token(NULLS_FIRST);
                                                                            orderColumn.setNullsLast(false);
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_12;
      }
      jj_consume_token(125);
      orderColumn = createOrderColumn(query);
                        list.add(orderColumn);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
      case DESC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
          jj_consume_token(ASC);
                  orderColumn.setDesc(false);
          break;
        case DESC:
          jj_consume_token(DESC);
                                                         orderColumn.setDesc(true);
          break;
        default:
          jj_la1[81] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULLS_LAST:
      case NULLS_FIRST:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NULLS_LAST:
          jj_consume_token(NULLS_LAST);
                          orderColumn.setNullsLast(true);
          break;
        case NULLS_FIRST:
          jj_consume_token(NULLS_FIRST);
                                                                            orderColumn.setNullsLast(false);
          break;
        default:
          jj_la1[83] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
    }
         query.setOrderColumns(list);
  }

  final public OrderColumn createOrderColumn(AbstractDMLQuery query) throws ParseException {
  String id = null;
  SelectColumn col = null;
  Token t = null;
  String alias = null;
    t = id();
        id = QueryProcessor.getDefaultConfig().isParserCaseSensitivity()? t.image : t.image.toUpperCase();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
      t = id();
                             alias = t.image;
      break;
    default:
      jj_la1[86] = jj_gen;
      ;
    }
        {if (true) return new OrderColumn(id, alias);}
    throw new Error("Missing return statement in function");
  }

  final public SelectColumn getSelectColumn(AbstractDMLQuery query) throws ParseException {
  String id = null;
  SelectColumn col = null;
  Token t = null;
  String alias = null;
    t = id();
        id = QueryProcessor.getDefaultConfig().isParserCaseSensitivity()? t.image : t.image.toUpperCase();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
      t = id();
                             alias = t.image;
      break;
    default:
      jj_la1[88] = jj_gen;
      ;
    }
        col = new SelectColumn(id, alias);
        {if (true) return col;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode SqlExpression(AbstractDMLQuery query) throws ParseException {
ExpNode exp1;
ExpNode exp2;
    exp1 = SqlAndExpression(query);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[89] = jj_gen;
        break label_13;
      }
      jj_consume_token(OR);
      exp2 = SqlAndExpression(query);
        exp1 = new OrNode(exp1,exp2);
    }
        {if (true) return exp1;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode SqlAndExpression(AbstractDMLQuery query) throws ParseException {
ExpNode exp1;
ExpNode exp2;
    exp1 = SqlSimpleExpression(query);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[90] = jj_gen;
        break label_14;
      }
      jj_consume_token(AND);
      exp2 = SqlSimpleExpression(query);
        exp1 =  new AndNode(exp1,exp2);
    }
        {if (true) return exp1;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode SqlSimpleExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      exp = condition(query);
      break;
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
      exp = SqlExpression(query);
      jj_consume_token(CLOSEPAREN);
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode SqlContainsItemExpression(AbstractDMLQuery query) throws ParseException {
ExpNode exp1;
ExpNode exp2;
    exp1 = SqlContainsItemSimpleExpression(query);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[92] = jj_gen;
        break label_15;
      }
      jj_consume_token(AND);
      exp2 = SqlContainsItemSimpleExpression(query);
        exp1 =  new AndNode(exp1,exp2);
    }
        {if (true) return exp1;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode SqlContainsItemSimpleExpression(AbstractDMLQuery query) throws ParseException {
        ExpNode exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      exp = containtsItemSimpleCondition(query);
      break;
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
      exp = SqlContainsItemSimpleExpression(query);
      jj_consume_token(CLOSEPAREN);
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

//handle one condition insinde contains, NOTE-currently no nested contains
  final public ExpNode containtsItemSimpleCondition(AbstractDMLQuery query) throws ParseException {
  Token t, table1 = null, table2 = null, addup = null, operator = null ;
        ColumnNode columnNode1 = null, columnNode2 = null;

        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        Token startIndex,endIndex;
        short templateMatchCode = TemplateMatchCodes.EQ;
        StringBuilder columnPath = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
      jj_consume_token(ROWNUM);
                        {if (true) throw new ParseException("ROWNUM not supported inside contains");}
      break;
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      columnNode1 = createColumnNode(query,null);

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLLECTION_CONTAINS:
        jj_consume_token(COLLECTION_CONTAINS);
                        query.setContainsQuery(true);
                        columnPath = new StringBuilder(columnNode1.toString());
                        columnPath.append("[*]");
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLLECTION_CONTAINS:
            ;
            break;
          default:
            jj_la1[94] = jj_gen;
            break label_16;
          }
          jj_consume_token(COLLECTION_CONTAINS);
                                                    columnPath.append("[*]");
        }
        label_17:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DOT:
            ;
            break;
          default:
            jj_la1[95] = jj_gen;
            break label_17;
          }
          jj_consume_token(DOT);
          t = id();
                                String columnNameSuffix = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
                                columnPath.append(".");
                                columnPath.append(columnNameSuffix);
          label_18:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COLLECTION_CONTAINS:
              ;
              break;
            default:
              jj_la1[96] = jj_gen;
              break label_18;
            }
            jj_consume_token(COLLECTION_CONTAINS);
                                                            columnPath.append("[*]");
          }
        }
                        expNode = containtsItemSimpleConditionImpl(query, columnPath, columnNode1, true);
        break;
      case BETWEEN:
      case IN:
      case LIKE:
      case NOT:
      case LESS:
      case LESSEQUAL:
      case GREATER:
      case GREATEREQUAL:
      case EQUAL:
      case NOTEQUAL:
      case NOTEQUAL2:
      case OPENPAREN:
        expNode = containtsItemSimpleConditionImpl(query, columnPath, columnNode1, false);
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       {if (true) return expNode;}
      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//handle one condition inside contains
  final public ExpNode containtsItemSimpleConditionImpl(AbstractDMLQuery query, StringBuilder columnPath, ColumnNode columnNode1, boolean insideInternalContains) throws ParseException {
  ExpNode expNode = null;
    if (jj_2_13(2)) {
      expNode = containsInItemNode(query,columnNode1,columnPath);
    } else if (jj_2_14(2)) {
      expNode = containsBetweenItemNode(query,columnNode1,columnPath);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIKE:
      case NOT:
      case LESS:
      case LESSEQUAL:
      case GREATER:
      case GREATEREQUAL:
      case EQUAL:
      case NOTEQUAL:
      case NOTEQUAL2:
      case OPENPAREN:
        expNode = containsSimpleItemNode(query,columnNode1,columnPath,insideInternalContains);
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
       {if (true) return expNode;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode SqlInClause(AbstractDMLQuery query) throws ParseException {
        ExpNode exp;
        boolean notIn = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
            notIn = true;
      break;
    default:
      jj_la1[100] = jj_gen;
      ;
    }
    jj_consume_token(IN);
    jj_consume_token(OPENPAREN);
    exp = inExprOrList(query,notIn);
    jj_consume_token(CLOSEPAREN);
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public String className() throws ParseException {
  StringBuffer buffer = new StringBuffer();
  Token name = null;
    name = id();
                     buffer.append(name.image);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case 126:
        ;
        break;
      default:
        jj_la1[101] = jj_gen;
        break label_19;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
                buffer.append(".");
        break;
      case 126:
        jj_consume_token(126);
                                          buffer.append("$");
        break;
      default:
        jj_la1[102] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      name = id();
                           buffer.append(name.image);
    }
         String classname = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? buffer.toString() : buffer.toString().toUpperCase();
         {if (true) return classname;}
    throw new Error("Missing return statement in function");
  }

  final public String sqlType() throws ParseException {
  Token param, param2=null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARCHAR:
      case VARCHAR2:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARCHAR:
          jj_consume_token(VARCHAR);
          break;
        case VARCHAR2:
          jj_consume_token(VARCHAR2);
          break;
        default:
          jj_la1[103] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          jj_consume_token(OPENPAREN);
          jj_consume_token(INTEGER_LITERAL);
          jj_consume_token(CLOSEPAREN);
          break;
        default:
          jj_la1[104] = jj_gen;
          ;
        }
                                                                                       {if (true) return String.class.getName();}
        break;
      case CHAR:
        jj_consume_token(CHAR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          jj_consume_token(OPENPAREN);
          jj_consume_token(INTEGER_LITERAL);
          jj_consume_token(CLOSEPAREN);
          break;
        default:
          jj_la1[105] = jj_gen;
          ;
        }
                                                                       {if (true) return String.class.getName();}
        break;
      case DATE:
        jj_consume_token(DATE);
                           {if (true) return Date.class.getName();}
        break;
      case DATETIME:
        jj_consume_token(DATETIME);
                               {if (true) return Timestamp.class.getName();}
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        jj_consume_token(OPENPAREN);
        param = jj_consume_token(INTEGER_LITERAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 125:
          jj_consume_token(125);
          param2 = jj_consume_token(INTEGER_LITERAL);
          break;
        default:
          jj_la1[106] = jj_gen;
          ;
        }
        jj_consume_token(CLOSEPAREN);
                          if (param2 != null && !param2.image.equals("0"))
                                {if (true) return Double.class.getName();}
                          int p = Integer.parseInt(param.image);
                          if (p < 10)
                                {if (true) return Integer.class.getName();}
                          else
                                {if (true) return Long.class.getName();}
        break;
      case TIME:
        jj_consume_token(TIME);
                           {if (true) return Time.class.getName();}
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          jj_consume_token(OPENPAREN);
          jj_consume_token(INTEGER_LITERAL);
          jj_consume_token(CLOSEPAREN);
          break;
        default:
          jj_la1[107] = jj_gen;
          ;
        }
                                                                        {if (true) return Float.class.getName();}
        break;
      case REAL:
        jj_consume_token(REAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          jj_consume_token(OPENPAREN);
          jj_consume_token(INTEGER_LITERAL);
          jj_consume_token(CLOSEPAREN);
          break;
        default:
          jj_la1[108] = jj_gen;
          ;
        }
                                                                       {if (true) return Float.class.getName();}
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
                             {if (true) return Double.class.getName();}
        break;
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
                              {if (true) return Boolean.class.getName();}
        break;
      case INTEGER:
      case INT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
          jj_consume_token(INTEGER);
          break;
        case INT:
          jj_consume_token(INT);
          break;
        default:
          jj_la1[109] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                        {if (true) return Integer.class.getName();}
        break;
      case LONG:
        jj_consume_token(LONG);
                           {if (true) return Long.class.getName();}
        break;
      case BLOB:
        jj_consume_token(BLOB);
                           {if (true) return Blob.class.getName();}
        break;
      case CLOB:
        jj_consume_token(CLOB);
                           {if (true) return Clob.class.getName();}
        break;
      case TIMESTAMP:
        jj_consume_token(TIMESTAMP);
                            {if (true) return Timestamp.class.getName();}
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
                          {if (true) return BigDecimal.class.getName();}
        break;
      case NUMERIC:
        jj_consume_token(NUMERIC);
                          {if (true) return BigDecimal.class.getName();}
        break;
      case LONGVARCHAR:
        jj_consume_token(LONGVARCHAR);
                              {if (true) return String.class.getName();}
        break;
      case TINYINT:
        jj_consume_token(TINYINT);
                          {if (true) return Byte.class.getName();}
        break;
      case SMALLINT:
        jj_consume_token(SMALLINT);
                           {if (true) return Short.class.getName();}
        break;
      case BIGINT:
        jj_consume_token(BIGINT);
                         {if (true) return Long.class.getName();}
        break;
      case BIT:
        jj_consume_token(BIT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          jj_consume_token(OPENPAREN);
          jj_consume_token(INTEGER_LITERAL);
          jj_consume_token(CLOSEPAREN);
          break;
        default:
          jj_la1[110] = jj_gen;
          ;
        }
                                                                      {if (true) return String.class.getName();}
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException p) {
                {if (true) throw new ParseException("unknown sql data type");}
    }
    throw new Error("Missing return statement in function");
  }

  final public Token id() throws ParseException {
  Token id = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      id = jj_consume_token(IDENTIFIER);
                              {if (true) return id;}
      break;
    case ESC_IDENTIFIER:
      id = jj_consume_token(ESC_IDENTIFIER);
                String idStr = id.image.substring(1,id.image.length()-1);
        id.image=idStr;
        {if (true) return id;}
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//handle one condition, and add it to the Query object
  final public ExpNode condition(AbstractDMLQuery query) throws ParseException {
  Token t, table1 = null, table2 = null, addup = null, operator = null ;
        ColumnNode columnNode1 = null, columnNode2 = null;

        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        Query innerQuery = null;
        RowNumNode rowNum;
        Token startIndex,endIndex;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROWNUM:
      jj_consume_token(ROWNUM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        jj_consume_token(EQUAL);
        t = jj_consume_token(INTEGER_LITERAL);
                                                 int temp = Integer.parseInt(t.image);
                                                                                 rowNum= new RowNumNode(temp,temp);
        break;
      case LESS:
        jj_consume_token(LESS);
        t = jj_consume_token(INTEGER_LITERAL);
                                         temp = Integer.parseInt(t.image);
                                                                                 rowNum= new RowNumNode(1, temp-1);
        break;
      case LESSEQUAL:
        jj_consume_token(LESSEQUAL);
        t = jj_consume_token(INTEGER_LITERAL);
                                              temp = Integer.parseInt(t.image);
                                                                                          rowNum= new RowNumNode(1, temp);
        break;
      case GREATER:
        jj_consume_token(GREATER);
        t = jj_consume_token(INTEGER_LITERAL);
                                              temp = Integer.parseInt(t.image);
                                                                                          rowNum= new RowNumNode(temp+1,Integer.MAX_VALUE);
        break;
      case GREATEREQUAL:
        jj_consume_token(GREATEREQUAL);
        t = jj_consume_token(INTEGER_LITERAL);
                                                temp = Integer.parseInt(t.image);
                                                                                            rowNum= new RowNumNode(temp,Integer.MAX_VALUE);
        break;
      case OPENPAREN:
        jj_consume_token(OPENPAREN);
        startIndex = jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(125);
        endIndex = jj_consume_token(INTEGER_LITERAL);
        jj_consume_token(CLOSEPAREN);
                rowNum= new RowNumNode(Integer.parseInt(startIndex.image),Integer.parseInt(endIndex.image));
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            if( query.getRownum() != null)
                        {if (true) throw new ParseException("Can't define more than a single condition for rownum. To specify range use rownum(from,to)");}
                query.setRownum(rowNum);
                {if (true) return null;}
      break;
    case IDENTIFIER:
    case ESC_IDENTIFIER:
      columnNode1 = createColumnNode(query,null);

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLLECTION_CONTAINS:
        expNode = containsNode(query,columnNode1);
        break;
      case IS:
        expNode = isNullNode(query,columnNode1);
        break;
      case BETWEEN:
        expNode = betweenNode(query,columnNode1);
        break;
      case IN:
      case LIKE:
      case RLIKE:
      case NOT:
      case LESS:
      case LESSEQUAL:
      case GREATER:
      case GREATEREQUAL:
      case EQUAL:
      case NOTEQUAL:
      case NOTEQUAL2:
        expNode = conditionNode(query,columnNode1);
        break;
      case RELATION:
        expNode = relationNode(query, columnNode1);
        break;
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        {if (true) return expNode;}
      break;
    default:
      jj_la1[115] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpNode relationNode(AbstractDMLQuery query,ColumnNode columnNode) throws ParseException {
        ValueNode valueNode = null;
        ExpNode res = null;
        Token rel = null;
        Token t;
    rel = jj_consume_token(RELATION);
    t = jj_consume_token(QUESTIONMARK);
                                        query.setPrepared(true);
                                        valueNode = new PreparedNode(null,++conditionIndex);
                                        res = new RelationNode(columnNode, rel.image, valueNode);
    {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode conditionNode(AbstractDMLQuery query,ColumnNode columnNode1) throws ParseException {
        Token t, addup = null, operator = null ;
        ValueNode valueNode = null;
        ExpNode expNode = null;
        String negative = "";
        Query innerQuery = null;
        ColumnNode columnNode2 = null;
    if (jj_2_18(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        jj_consume_token(EQUAL);
                                  expNode = new EqualNode();
        break;
      case LESS:
        jj_consume_token(LESS);
                                          expNode = new LTNode();
        break;
      case LESSEQUAL:
        jj_consume_token(LESSEQUAL);
                                  expNode = new LTENode();
        break;
      case GREATER:
        jj_consume_token(GREATER);
                                  expNode = new GTNode();
        break;
      case GREATEREQUAL:
        jj_consume_token(GREATEREQUAL);
                                  expNode = new GTENode();
        break;
      case NOTEQUAL:
        jj_consume_token(NOTEQUAL);
                                  expNode = new NotEqualNode();
        break;
      case NOTEQUAL2:
        jj_consume_token(NOTEQUAL2);
                                  expNode = new NotEqualNode();
        break;
      case LIKE:
        jj_consume_token(LIKE);
                                  expNode = new LikeNode();
        break;
      case NOT:
        jj_consume_token(NOT);
        jj_consume_token(LIKE);
                                  expNode = new NotLikeNode();
        break;
      case RLIKE:
        jj_consume_token(RLIKE);
                                  expNode = new RLikeNode();
        break;
      default:
        jj_la1[116] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUESTIONMARK:
        t = jj_consume_token(QUESTIONMARK);
                                     query.setPrepared(true); valueNode = new PreparedNode(null,++conditionIndex);
        break;
      case STRING_LITERAL:
        t = jj_consume_token(STRING_LITERAL);
                                         valueNode = new LiteralNode(new String(t.image.substring(1,t.image.length()-1)));
        break;
      case TRUE:
        t = jj_consume_token(TRUE);
                               valueNode = new LiteralNode(Boolean.TRUE);
        break;
      case FALSE:
        t = jj_consume_token(FALSE);
                               valueNode = new LiteralNode(Boolean.FALSE);
        break;
      default:
        jj_la1[122] = jj_gen;
        if (jj_2_15(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            jj_consume_token(MINUS);
                                         negative = "-";
            break;
          default:
            jj_la1[117] = jj_gen;
            ;
          }
          t = jj_consume_token(INTEGER_LITERAL);
                                                                                   valueNode = new LiteralNode(negative + t.image);
        } else if (jj_2_16(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            jj_consume_token(MINUS);
                                         negative = "-";
            break;
          default:
            jj_la1[118] = jj_gen;
            ;
          }
          t = jj_consume_token(LONG_LITERAL);
                                                                                valueNode = new LiteralNode(negative + t.image.substring(0,t.image.length()-1));
        } else if (jj_2_17(2)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MINUS:
            jj_consume_token(MINUS);
                                         negative = "-";
            break;
          default:
            jj_la1[119] = jj_gen;
            ;
          }
          t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                                          valueNode = new LiteralNode(negative + t.image);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DATE_LITERAL:
            t = jj_consume_token(DATE_LITERAL);
                                      valueNode = new LiteralNode(t.image);
            break;
          case SYSDATE:
            jj_consume_token(SYSDATE);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case PLUS:
            case MINUS:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case PLUS:
                operator = jj_consume_token(PLUS);
                break;
              case MINUS:
                operator = jj_consume_token(MINUS);
                break;
              default:
                jj_la1[120] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              addup = jj_consume_token(INTEGER_LITERAL);
              break;
            default:
              jj_la1[121] = jj_gen;
              ;
            }
                        Calendar cal = Calendar.getInstance();
                        if (addup != null) {
                                if (operator.image.equals("+"))
                                        cal.add(Calendar.DATE,Integer.parseInt(addup.image));
                                else if (operator.image.equals("-"))
                                        cal.add(Calendar.DATE,-(Integer.parseInt(addup.image)));
                        }
                        valueNode = new LiteralNode(new java.sql.Timestamp(cal.getTime().getTime()));
            break;
          case OPENPAREN:
            jj_consume_token(OPENPAREN);
            innerQuery = selectSql();
                  valueNode = new InnerQueryNode((SelectQuery)innerQuery); query.setContainsSubQueries(true);
            jj_consume_token(CLOSEPAREN);
            break;
          case IDENTIFIER:
          case ESC_IDENTIFIER:
            columnNode2 = createColumnNode(query,null);

            break;
          default:
            jj_la1[123] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } else if (jj_2_19(2)) {
      expNode = SqlInClause(query);
                          expNode.setLeftChild(columnNode1);
                          {if (true) return expNode;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
      expNode.setLeftChild(columnNode1);
     if ( columnNode2 == null )
        expNode.setRightChild(valueNode);
     else {
        expNode.setRightChild(columnNode2);
     }
     {if (true) return expNode;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode isNullNode(AbstractDMLQuery query,ColumnNode columnNode1) throws ParseException {
        IsNullNode expNode = null;
    if (jj_2_20(2)) {
      jj_consume_token(IS);
      jj_consume_token(NULL);
                                  expNode = new IsNullNode(columnNode1, new LiteralNode(null));
    } else if (jj_2_21(2)) {
      jj_consume_token(IS);
      jj_consume_token(NOT);
      jj_consume_token(NULL);
                  expNode = new IsNullNode(columnNode1, new LiteralNode(null));
          expNode.setNot(true);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return expNode;}
    throw new Error("Missing return statement in function");
  }

  final public AndNode betweenNode(AbstractDMLQuery query,ColumnNode columnNode1) throws ParseException {
        ValueNode valueNode = null;
        ExpNode expNode = null;
    jj_consume_token(BETWEEN);
                                ExpNode gteNode = new GTENode(columnNode1, null);
                                ExpNode lteNode = new LTENode(columnNode1, null);
    valueNode = getBetweenValueNode(query);
                                                                   gteNode.setRightChild(valueNode);
    jj_consume_token(AND);
    valueNode = getBetweenValueNode(query);
                                                                   lteNode.setRightChild(valueNode);
                          {if (true) return new AndNode(gteNode, lteNode);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsSimpleItemNode(AbstractDMLQuery query,ColumnNode columnNode1,StringBuilder columnPath, boolean insideInternalContains) throws ParseException {
Token t, table1 = null, table2 = null, addup = null, operator = null ;
        ColumnNode columnNode2 = null;

        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        Token startIndex,endIndex;
        short templateMatchCode = TemplateMatchCodes.EQ;
        ContainsItemNode containsItems =null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
                  templateMatchCode = TemplateMatchCodes.EQ;
      break;
    case LESS:
      jj_consume_token(LESS);
                   templateMatchCode = TemplateMatchCodes.LT;
      break;
    case LESSEQUAL:
      jj_consume_token(LESSEQUAL);
                        templateMatchCode = TemplateMatchCodes.LE;
      break;
    case GREATER:
      jj_consume_token(GREATER);
                      templateMatchCode = TemplateMatchCodes.GT;
      break;
    case GREATEREQUAL:
      jj_consume_token(GREATEREQUAL);
                           templateMatchCode = TemplateMatchCodes.GE;
      break;
    case NOTEQUAL:
      jj_consume_token(NOTEQUAL);
                       templateMatchCode = TemplateMatchCodes.NE;
      break;
    case NOTEQUAL2:
      jj_consume_token(NOTEQUAL2);
                        templateMatchCode = TemplateMatchCodes.NE;
      break;
    case LIKE:
      jj_consume_token(LIKE);
                          templateMatchCode = TemplateMatchCodes.REGEX;
      break;
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(LIKE);
                          templateMatchCode = TemplateMatchCodes.NOT_REGEX;
      break;
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
                  columnNode1.setName(columnPath.toString());
                  valueNode = new ContainsItemsRootNode(SqlContainsItemExpression(query),columnPath.toString(),columnNode1);
      jj_consume_token(CLOSEPAREN);
                                if ( insideInternalContains)
                         {if (true) return new ContainsItemNode(columnNode1,valueNode,templateMatchCode);}

                                 {if (true) throw new ParseException("invalid token inside contains conditions");}
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTIONMARK:
      t = jj_consume_token(QUESTIONMARK);
                                     query.setPrepared(true); valueNode = new PreparedNode(null,++conditionIndex);
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                                         valueNode = new LiteralNode(new String(t.image.substring(1,t.image.length()-1)));
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
                               valueNode = new LiteralNode(Boolean.TRUE);
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
                               valueNode = new LiteralNode(Boolean.FALSE);
      break;
    default:
      jj_la1[128] = jj_gen;
      if (jj_2_22(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                                         negative = "-";
          break;
        default:
          jj_la1[125] = jj_gen;
          ;
        }
        t = jj_consume_token(INTEGER_LITERAL);
                                                                                   valueNode = new LiteralNode(new Integer(negative + t.image));
      } else if (jj_2_23(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                                         negative = "-";
          break;
        default:
          jj_la1[126] = jj_gen;
          ;
        }
        t = jj_consume_token(LONG_LITERAL);
                                                                                valueNode = new LiteralNode(negative + t.image.substring(0,t.image.length()-1));
      } else if (jj_2_24(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                                         negative = "-";
          break;
        default:
          jj_la1[127] = jj_gen;
          ;
        }
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                                          valueNode = new LiteralNode(negative + t.image);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATE_LITERAL:
          t = jj_consume_token(DATE_LITERAL);
                                      valueNode = new LiteralNode(t.image);
          break;
        default:
          jj_la1[129] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
                if (columnPath != null)
                         columnNode1.setName(columnPath.toString());
                        {if (true) return new ContainsItemNode(columnNode1, valueNode, templateMatchCode);}
    throw new Error("Missing return statement in function");
  }

  final public AndNode containsBetweenItemNode(AbstractDMLQuery query,ColumnNode columnNode1,StringBuilder columnPath) throws ParseException {
               ValueNode gteValue ,lteValue ;
    jj_consume_token(BETWEEN);
    gteValue = getBetweenValueNode(query);
    jj_consume_token(AND);
    lteValue = getBetweenValueNode(query);
                        if (columnPath != null)
                                columnNode1.setName(columnPath.toString());
                        ExpNode gteNode = new ContainsItemNode(columnNode1, gteValue, TemplateMatchCodes.GE);
                        ExpNode lteNode = new ContainsItemNode(columnNode1, lteValue,TemplateMatchCodes.LE);

                    {if (true) return new AndNode(gteNode, lteNode);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsInItemNode(AbstractDMLQuery query,ColumnNode columnNode1,StringBuilder columnPath) throws ParseException {
    ExpNode inNode;
        boolean notIn = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
              notIn = true;
      break;
    default:
      jj_la1[130] = jj_gen;
      ;
    }
    jj_consume_token(IN);
    jj_consume_token(OPENPAREN);
    inNode = inExprOrList(query,notIn);
    jj_consume_token(CLOSEPAREN);
                        if (columnPath != null)
                                columnNode1.setName(columnPath.toString());
                        inNode.setLeftChild(columnNode1);

                        {if (true) return new ContainsItemNode(columnNode1, inNode, TemplateMatchCodes.IN);}
    throw new Error("Missing return statement in function");
  }

  final public AndNode containsBetweenNode(AbstractDMLQuery query,ColumnNode columnNode1,String column) throws ParseException {
               ValueNode gteValue ,lteValue ;
    jj_consume_token(BETWEEN);
    gteValue = getBetweenValueNode(query);
    jj_consume_token(AND);
    lteValue = getBetweenValueNode(query);
                        columnNode1.setName(column);
                        ExpNode gteNode = new ContainsNode(columnNode1, gteValue, TemplateMatchCodes.GE);
                        ExpNode lteNode = new ContainsNode(columnNode1, lteValue,TemplateMatchCodes.LE);

                   {if (true) return new AndNode(gteNode, lteNode);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsSimpleNode(AbstractDMLQuery query,ColumnNode columnNode1,String column) throws ParseException {
        ValueNode valueNode = null;
        short templateMatchCode;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
                          templateMatchCode = TemplateMatchCodes.EQ;
      break;
    case LESS:
      jj_consume_token(LESS);
                           templateMatchCode = TemplateMatchCodes.LT;
      break;
    case LESSEQUAL:
      jj_consume_token(LESSEQUAL);
                                templateMatchCode = TemplateMatchCodes.LE;
      break;
    case GREATER:
      jj_consume_token(GREATER);
                              templateMatchCode = TemplateMatchCodes.GT;
      break;
    case GREATEREQUAL:
      jj_consume_token(GREATEREQUAL);
                                   templateMatchCode = TemplateMatchCodes.GE;
      break;
    case NOTEQUAL:
      jj_consume_token(NOTEQUAL);
                               templateMatchCode = TemplateMatchCodes.NE;
      break;
    case NOTEQUAL2:
      jj_consume_token(NOTEQUAL2);
                                templateMatchCode = TemplateMatchCodes.NE;
      break;
    case LIKE:
      jj_consume_token(LIKE);
                              templateMatchCode = TemplateMatchCodes.REGEX;
      break;
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(LIKE);
                              templateMatchCode = TemplateMatchCodes.NOT_REGEX;
      break;
    default:
      jj_la1[131] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    valueNode = valueNode(query);
                columnNode1.setName(column);
                {if (true) return new ContainsNode(columnNode1, valueNode, templateMatchCode);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsInNode(AbstractDMLQuery query,ColumnNode columnNode1,String column) throws ParseException {
    ExpNode inNode;
        boolean notIn = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
              notIn = true;
      break;
    default:
      jj_la1[132] = jj_gen;
      ;
    }
    jj_consume_token(IN);
    jj_consume_token(OPENPAREN);
    inNode = inExprOrList(query,notIn);
    jj_consume_token(CLOSEPAREN);
        columnNode1.setName(column);
                inNode.setLeftChild(columnNode1);

                {if (true) return new ContainsNode(columnNode1, inNode, TemplateMatchCodes.IN);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsNode(AbstractDMLQuery query,ColumnNode columnNode1) throws ParseException {
        Token t;
        ValueNode valueNode = null;
        String negative = "";
        ExpNode expNode = null;
        ContainsItemNode containsItems =null;
    jj_consume_token(COLLECTION_CONTAINS);
                        query.setContainsQuery(true);
                        StringBuilder columnPath = new StringBuilder(columnNode1.toString());
                        columnPath.append("[*]");
                        short templateMatchCode = TemplateMatchCodes.EQ;
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLLECTION_CONTAINS:
        ;
        break;
      default:
        jj_la1[133] = jj_gen;
        break label_20;
      }
      jj_consume_token(COLLECTION_CONTAINS);
                                                    columnPath.append("[*]");
    }
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[134] = jj_gen;
        break label_21;
      }
      jj_consume_token(DOT);
      t = id();
                                String columnNameSuffix = (QueryProcessor.getDefaultConfig().isParserCaseSensitivity()) ? t.image : t.image.toUpperCase();
                                columnPath.append(".");
                                columnPath.append(columnNameSuffix);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLLECTION_CONTAINS:
          ;
          break;
        default:
          jj_la1[135] = jj_gen;
          break label_22;
        }
        jj_consume_token(COLLECTION_CONTAINS);
                                                            columnPath.append("[*]");
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BETWEEN:
    case IN:
    case LIKE:
    case NOT:
    case LESS:
    case LESSEQUAL:
    case GREATER:
    case GREATEREQUAL:
    case EQUAL:
    case NOTEQUAL:
    case NOTEQUAL2:
      expNode = containsSingleNode(query,columnNode1,columnPath.toString());
      break;
    case OPENPAREN:
      expNode = containsMultipleNode(query,columnNode1,columnPath.toString());
      break;
    default:
      jj_la1[136] = jj_gen;
      if (jj_2_25(2)) {
        expNode = containsIsNullNode(query,columnNode1,columnPath.toString());
      } else if (jj_2_26(2)) {
        expNode = containsIsNotNullNode(query,columnNode1,columnPath.toString());
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return expNode;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsIsNullNode(AbstractDMLQuery query,ColumnNode columnNode1,String columnPath) throws ParseException {
        IsNullNode valueNode = null;
    jj_consume_token(IS);
    jj_consume_token(NULL);
        //comment
        valueNode = new IsNullNode(columnNode1, new LiteralNode(null));
        columnNode1.setName(columnPath);
        {if (true) return new ContainsNode(columnNode1, valueNode, TemplateMatchCodes.IS_NULL);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsIsNotNullNode(AbstractDMLQuery query,ColumnNode columnNode1,String columnPath) throws ParseException {
        IsNullNode valueNode = null;
    jj_consume_token(IS);
    jj_consume_token(NOT);
    jj_consume_token(NULL);
        //comment
        valueNode = new IsNullNode(columnNode1, new LiteralNode(null));
        valueNode.setNot(true);
        columnNode1.setName(columnPath);
        {if (true) return new ContainsNode(columnNode1, valueNode, TemplateMatchCodes.NOT_NULL);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsMultipleNode(AbstractDMLQuery query,ColumnNode columnNode1,String columnPath) throws ParseException {
        ValueNode valueNode = null;
    jj_consume_token(OPENPAREN);
          columnNode1.setName(columnPath);
          valueNode = new ContainsItemsRootNode(SqlContainsItemExpression(query),columnPath,columnNode1);
    jj_consume_token(CLOSEPAREN);
         {if (true) return new ContainsItemNode(columnNode1,valueNode,TemplateMatchCodes.EQ);}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode containsSingleNode(AbstractDMLQuery query,ColumnNode columnNode1,String column) throws ParseException {
        ExpNode expNode = null;
    if (jj_2_27(2)) {
      expNode = containsInNode(query,columnNode1,column);
    } else if (jj_2_28(2)) {
      expNode = containsBetweenNode(query,columnNode1,column);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LIKE:
      case NOT:
      case LESS:
      case LESSEQUAL:
      case GREATER:
      case GREATEREQUAL:
      case EQUAL:
      case NOTEQUAL:
      case NOTEQUAL2:
        expNode = containsSimpleNode(query,columnNode1,column);
        break;
      default:
        jj_la1[137] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return expNode;}
    throw new Error("Missing return statement in function");
  }

  final public ValueNode valueNode(AbstractDMLQuery query) throws ParseException {
        Token t;
        ValueNode valueNode = null;
        String negative = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTIONMARK:
      t = jj_consume_token(QUESTIONMARK);
                              query.setPrepared(true); valueNode = new PreparedNode(null,++conditionIndex);
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                                         valueNode = new LiteralNode(new String(t.image.substring(1,t.image.length()-1)));
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
                               valueNode = new LiteralNode(Boolean.TRUE);
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
                               valueNode = new LiteralNode(Boolean.FALSE);
      break;
    default:
      jj_la1[141] = jj_gen;
      if (jj_2_29(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                                         negative = "-";
          break;
        default:
          jj_la1[138] = jj_gen;
          ;
        }
        t = jj_consume_token(INTEGER_LITERAL);
                                                                                   valueNode = new LiteralNode(new Integer(negative + t.image));
      } else if (jj_2_30(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                                         negative = "-";
          break;
        default:
          jj_la1[139] = jj_gen;
          ;
        }
        t = jj_consume_token(LONG_LITERAL);
                                                                                valueNode = new LiteralNode(negative + t.image.substring(0,t.image.length()-1));
      } else if (jj_2_31(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                                         negative = "-";
          break;
        default:
          jj_la1[140] = jj_gen;
          ;
        }
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                                          valueNode = new LiteralNode(negative + t.image);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATE_LITERAL:
          t = jj_consume_token(DATE_LITERAL);
                                      valueNode = new LiteralNode(t.image);
          break;
        default:
          jj_la1[142] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
                {if (true) return valueNode;}
    throw new Error("Missing return statement in function");
  }

  final public ExpNode inExprOrList(AbstractDMLQuery query,boolean isNot) throws ParseException {
Query innerQuery = null;
ExpNode expNode = null;
HashSet<LiteralNode> valuelist;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      innerQuery = selectSql();
            if (isNot) {
                expNode = new NotInNode();
            } else {
                        expNode = new InNode();
                }
                query.setContainsSubQueries(true);
                expNode.setRightChild(new InnerQueryNode((SelectQuery)innerQuery));
                {if (true) return expNode;}
      break;
    case NULL:
    case EMPTY_CLOB:
    case EMPTY_BLOB:
    case TRUE:
    case FALSE:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case MINUS:
    case QUESTIONMARK:
      valuelist = inValueList(query);
            if (isNot)
            {
              expNode = new NotInNode();
              ((NotInNode)expNode).setValuesList(valuelist);
            }
            else
            {
                  expNode = new InNode();
                ((InNode)expNode).setValuesList(valuelist);
                }
                {if (true) return expNode;}
      break;
    default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LiteralNode parseInValue(AbstractDMLQuery query) throws ParseException {
  Token t = null;
  LiteralNode value = null;
  String negative = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      t = jj_consume_token(TRUE);
                                value = new LiteralNode(Boolean.TRUE);
      break;
    case FALSE:
      jj_consume_token(FALSE);
                            value = new LiteralNode(Boolean.FALSE);
      break;
    case NULL:
      jj_consume_token(NULL);
                                    value = new LiteralNode(null);
      break;
    case EMPTY_CLOB:
      jj_consume_token(EMPTY_CLOB);
                                     value = new LiteralNode(new Clob(""));
      break;
    case EMPTY_BLOB:
      jj_consume_token(EMPTY_BLOB);
                                     value = new LiteralNode(new Blob(new byte[0]));
      break;
    case QUESTIONMARK:
      jj_consume_token(QUESTIONMARK);
                                 query.setPrepared(true); value =  new PreparedNode(null, ++conditionIndex);
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                             value = new LiteralNode(new String(t.image.substring(1,t.image.length()-1)));
      break;
    default:
      jj_la1[147] = jj_gen;
      if (jj_2_32(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[144] = jj_gen;
          ;
        }
        t = jj_consume_token(INTEGER_LITERAL);
                                                                       value = new LiteralNode(negative + t.image);
      } else if (jj_2_33(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[145] = jj_gen;
          ;
        }
        t = jj_consume_token(LONG_LITERAL);
                                                                    value = new LiteralNode(negative + t.image.substring(0,t.image.length()-1));
      } else if (jj_2_34(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[146] = jj_gen;
          ;
        }
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                              value = new LiteralNode(negative + t.image);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<LiteralNode> inValueList(AbstractDMLQuery query) throws ParseException {
  LiteralNode value = null;
  HashSet<LiteralNode> list = new HashSet<LiteralNode>();
    value = parseInValue(query);
                                       list.add(value);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        ;
        break;
      default:
        jj_la1[148] = jj_gen;
        break label_23;
      }
      jj_consume_token(125);
      value = parseInValue(query);
                                         list.add(value) ;
    }
          {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public ValueNode getBetweenValueNode(AbstractDMLQuery query) throws ParseException {
        ValueNode valueNode = null;
        Token t = null, operator = null, addup = null;
        String negative = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTIONMARK:
      t = jj_consume_token(QUESTIONMARK);
                             query.setPrepared(true); valueNode = new PreparedNode(null,++conditionIndex);
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                             valueNode = new LiteralNode(new String(t.image.substring(1,t.image.length()-1)));
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
                   valueNode = new LiteralNode(Boolean.TRUE);
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
                   valueNode = new LiteralNode(Boolean.FALSE);
      break;
    default:
      jj_la1[154] = jj_gen;
      if (jj_2_35(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[149] = jj_gen;
          ;
        }
        t = jj_consume_token(INTEGER_LITERAL);
                                                                       valueNode = new LiteralNode(negative + t.image);
      } else if (jj_2_36(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[150] = jj_gen;
          ;
        }
        t = jj_consume_token(LONG_LITERAL);
                                                                    valueNode = new LiteralNode(negative + t.image.substring(0,t.image.length()-1));
      } else if (jj_2_37(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          jj_consume_token(MINUS);
                             negative = "-";
          break;
        default:
          jj_la1[151] = jj_gen;
          ;
        }
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                                                                              valueNode = new LiteralNode(negative + t.image);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATE_LITERAL:
          t = jj_consume_token(DATE_LITERAL);
                          valueNode = new LiteralNode(t.image);
          break;
        case SYSDATE:
          jj_consume_token(SYSDATE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
          case MINUS:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case PLUS:
              operator = jj_consume_token(PLUS);
              break;
            case MINUS:
              operator = jj_consume_token(MINUS);
              break;
            default:
              jj_la1[152] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            addup = jj_consume_token(INTEGER_LITERAL);
            break;
          default:
            jj_la1[153] = jj_gen;
            ;
          }
                Calendar cal = Calendar.getInstance();
                if (addup != null) {
                        if (operator.image.equals("+"))
                                cal.add(Calendar.DATE,Integer.parseInt(addup.image));
                        else if (operator.image.equals("-"))
                                cal.add(Calendar.DATE,-(Integer.parseInt(addup.image)));
                }
                valueNode = new LiteralNode(new java.sql.Timestamp(cal.getTime().getTime()));
          break;
        default:
          jj_la1[155] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
          {if (true) return valueNode;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_3_25() {
    if (jj_3R_60()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(SYSDATE)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(DATE_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(QUESTIONMARK)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    }
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(OPENPAREN)) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(OPENPAREN)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) jj_scanpos = xsp;
    if (jj_scan_token(IN)) return true;
    if (jj_scan_token(OPENPAREN)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(SYSDATE)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) jj_scanpos = xsp;
    if (jj_scan_token(IN)) return true;
    if (jj_scan_token(OPENPAREN)) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(DATE_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(QUESTIONMARK)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(RLIKE)) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(NOTEQUAL2)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(NOTEQUAL)) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(GREATEREQUAL)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(GREATER)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(LESSEQUAL)) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_scan_token(AVG)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(MIN)) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_scan_token(MAX)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(COUNT)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(SUM)) return true;
    return false;
  }

  private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    }
    }
    }
    }
    if (jj_scan_token(OPENPAREN)) return true;
    return false;
  }

  private boolean jj_3_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(BETWEEN)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) jj_scanpos = xsp;
    if (jj_scan_token(IN)) return true;
    if (jj_scan_token(OPENPAREN)) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(BETWEEN)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) jj_scanpos = xsp;
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) jj_scanpos = xsp;
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_25()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(ESC_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_25()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_61()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SqlParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[156];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xe020,0x1,0x40080,0x0,0x0,0x0,0x200000,0x80000000,0x0,0x4000,0x1,0x0,0x200000,0x80000000,0x0,0x0,0x1,0x0,0x200000,0x80000000,0x0,0x1,0x0,0x1000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x10000,0x0,0x0,0x10000000,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0xc000400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x20200,0x20200,0x0,0x0,0x0,0x20200,0x20200,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x100,0x0,0x100,0x0,0x0,0x0,0x0,0x11400800,0x0,0x11000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x13c00800,0x0,0x13000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11000000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x11000000,0x10000000,0x0,0x0,0x0,0x11400800,0x11000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xc8441,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x4000,0x0,0x0,0x100,0x0,0x0,0x4000,0x100,0x0,0x100,0x0,0x0,0x4000,0x0,0x10,0x0,0x10,0x0,0x0,0x20001,0x0,0x100200,0x100200,0x0,0x0,0x0,0x0,0x100200,0x100200,0x0,0x300000,0x0,0xc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x400000,0x0,0x400000,0x400000,0x0,0x0,0x0,0x24,0x0,0x1000000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x6000000,0x0,0x0,0x0,0x6000000,0x6000000,0x1000000,0x1000000,0x1000000,0x1000000,0x0,0x0,0x100,0x0,0x100,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8000000,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x0,0x0,0x0,0x3000000,0x0,0x3000000,0x0,0x0,0x0,0x0,0x0,0x3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x0,0x0,0xe3000000,0x0,0xe3000000,0xe3000000,0x0,0x0,0x3000000,0x3000000,0x0,0x3000000,0x3000000,0x0,0x0,0xe301b000,0x0,0x3000000,0x0,0x3000000,0x3000000,0x0,0xe3000000,0x3000000,0x0,0x3000000,0x3000000,0x0,0x0,0x0,0x1b000,0x0,0x0,0x0,0x0,0x1b000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x0,0x3000000,0x0,0x0,0x3000000,0x0,0x3000000,0x0,0x0,0x0,0x0,0x3000000,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x0,0x20020,0x0,0xfe0fff,0x3000000,0x0,0x10000000,0x3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x18000,0x3000000,0x0,0x0,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000,0x0,0xe001b000,0x0,0x0,0x0,0x1b000,0x0,0x0,0x0,0x0,0x0,0x0,0x18000,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x20,0x0,0x20000,0x40000,0x0,0x0,0x0,0x0,0x0,0x20,0x20000,0x0,0x0,0x0,0x20000,0x20,0x20000,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x20000,0x40000,0x20000,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x2000002,0x20000000,0x2000002,0x2000002,0x0,0x20000000,0x200002,0x200002,0x20000000,0x200002,0x200002,0x20000000,0x1000000,0x2000002,0x0,0x200000,0x0,0x0,0x0,0x20000000,0x2,0x0,0x20000000,0x0,0x0,0x1000000,0x1000000,0x1000000,0x2000002,0x20000000,0x1000000,0x1000000,0x1000000,0x2000002,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x20000,0x10000000,0x40,0x10000000,0x1002fe00,0x0,0x2fe00,0x0,0x40000040,0x40000040,0x0,0x20000,0x20000,0x20000000,0x20000,0x20000,0x0,0x20000,0x0,0x0,0x23e00,0x1000fe00,0x0,0xfe00,0x1000000,0x1000000,0x1000000,0x1800000,0x1800000,0x2000002,0x20004,0x2fe00,0x1000000,0x1000000,0x1000000,0x2000002,0x4,0x0,0xfe00,0x0,0x10000000,0x40,0x10000000,0x2fe00,0xfe00,0x1000000,0x1000000,0x1000000,0x2000002,0x4,0x3000002,0x1000000,0x1000000,0x1000000,0x2000002,0x20000000,0x1000000,0x1000000,0x1000000,0x1800000,0x1800000,0x2000002,0x4,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[37];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SqlParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SqlParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 156; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 156; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SqlParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 156; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 156; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SqlParser(SqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 156; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 156; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[127];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 156; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 127; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 37; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
