/*
 * Copyright (c) 2008-2016, GigaSpaces Technologies, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.gigaspaces.internal.server.space.operations;

import com.gigaspaces.client.*;
import com.gigaspaces.client.mutators.SpaceEntryMutator;
import com.gigaspaces.internal.client.ChangeDetailedResultImpl;
import com.gigaspaces.internal.client.ChangeEntryDetailsImpl;
import com.gigaspaces.internal.client.ChangeResultImpl;
import com.gigaspaces.internal.client.FailedChangedEntryDetailsImpl;
import com.gigaspaces.internal.client.spaceproxy.operations.ChangeEntriesSpaceOperationRequest;
import com.gigaspaces.internal.client.spaceproxy.operations.ChangeEntriesSpaceOperationResult;
import com.gigaspaces.internal.metadata.ITypeDesc;
import com.gigaspaces.internal.metadata.TypeDescriptorUtils;
import com.gigaspaces.internal.server.space.SpaceImpl;
import com.gigaspaces.internal.server.storage.IEntryData;
import com.gigaspaces.lrmi.nio.IResponseContext;
import com.gigaspaces.lrmi.nio.ResponseContext;
import com.gigaspaces.security.authorities.SpaceAuthority.SpacePrivilege;
import com.gigaspaces.utils.CodeChangeUtilities;
import com.j_spaces.core.ExtendedAnswerHolder;
import com.j_spaces.core.client.Modifiers;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * @author eitany
 * @since 9.1
 */
@com.gigaspaces.api.InternalApi
public class ChangeEntriesSpaceOperation
        extends AbstractSpaceOperation<ChangeEntriesSpaceOperationResult, ChangeEntriesSpaceOperationRequest> {

    @Override
    public void execute(ChangeEntriesSpaceOperationRequest request,
                        ChangeEntriesSpaceOperationResult result, SpaceImpl space,
                        boolean oneway) throws Exception {
        try{
            validateClientMvccCompatible(space);
            IResponseContext respContext = ResponseContext.getResponseContext();
            if (respContext != null)
                respContext.setInvokedFromNewRouter(true);

            SpacePrivilege requiredPrivilege = getRequiredPrivilege(request.getMutators());

            space.beginPacketOperation(true, request.getSpaceContext(), requiredPrivilege, request.getTemplatePacket());

            ExtendedAnswerHolder answerHolder =
                    space.getEngine().change(request.getTemplatePacket(),
                            request.getTransaction(),
                            request.getLease(),
                            request.getTimeout(),
                            request.getSpaceContext(),
                            false /* fromReplication */,
                            true /* origin */,
                            request.getMutators(),
                            request.getModifiers(),
                            false);
            //Should be after the template has its type descriptor filled
            //TODO MU: (GS-10649)currently entryData does not contain the id if it is autogenerated, so we can't
            //rely on getting to id from the rejected/modified entry until we fix this. Since we only match by id at the moment
            //we can safely take the id from the template is it should match the updated entry
            Object uid = request.getTemplatePacket().getUID();
            boolean byId = (uid != null || (request.getTemplatePacket().getID() != null && (request.getTemplatePacket().getExtendedMatchCodes() == null && request.getTemplatePacket().getCustomQuery() == null)));
            if (byId)
                setResult(result, answerHolder, request.getModifiers(), uid);
            else
                setMultipleEntriesResult(result, answerHolder, request.getModifiers());
            if (Modifiers.contains(request.getModifiers(), Modifiers.LOG_SCANNED_ENTRIES_COUNT))
                result.setNumOfEntriesMatched(answerHolder.getNumOfEntriesMatched());
        }
        finally {
            CodeChangeUtilities.removeOneTimeClassLoaderIfNeeded(request.getMutators());
        }
    }


    private static SpacePrivilege getRequiredPrivilege(
            Collection<SpaceEntryMutator> mutators) {
        for (SpaceEntryMutator spaceEntryMutator : mutators) {
            if (spaceEntryMutator instanceof CustomChangeOperation)
                return SpacePrivilege.EXECUTE;
        }

        return SpacePrivilege.WRITE;
    }

    @SuppressWarnings("unchecked")
    public static void setResult(ChangeEntriesSpaceOperationResult result,
                                 ExtendedAnswerHolder answerHolder, int modifiers, Object templateUid) {
        Throwable exception = answerHolder.getException();
        IEntryData modifiedEntryData = answerHolder.getModifiedEntryData();
        IEntryData rejectedEntry = answerHolder.getRejectedEntry();
        final boolean isDetailedResult = Modifiers.contains(modifiers, Modifiers.RETURN_DETAILED_CHANGE_RESULT);
        ChangeResult<?> resultImpl = null;
        if (modifiedEntryData != null) {
            if (isDetailedResult) {
                Object idValue = extractId(templateUid, modifiedEntryData);
                resultImpl = new ChangeDetailedResultImpl(new ChangeEntryDetailsImpl(modifiedEntryData.getSpaceTypeDescriptor().getTypeName(),
                        idValue,
                        modifiedEntryData.getVersion(),
                        answerHolder.getChangeResults()));
            } else {
                resultImpl = ChangeResultImpl.SINGLE;
            }
        } else if (rejectedEntry != null) {
            Object idValue = extractId(templateUid, rejectedEntry);
            FailedChangedEntryDetails failedChangeResult = new FailedChangedEntryDetailsImpl(rejectedEntry.getSpaceTypeDescriptor().getTypeName(),
                    idValue,
                    rejectedEntry.getVersion(),
                    exception);
            Collection<FailedChangedEntryDetails> entriesFailedToChange = Collections.singletonList(failedChangeResult);
            result.setExecutionException(new ChangeException("Failed changing entry in space - " + exception.getMessage(), Collections.EMPTY_LIST, entriesFailedToChange, Collections.EMPTY_LIST));
        } else if (exception != null) {
            result.setExecutionException(new ChangeException("Failed changing entry in space - " + exception.getMessage(), Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.singletonList(exception)));
        } else {
            if (isDetailedResult)
                resultImpl = ChangeDetailedResultImpl.EMPTY;
            else
                resultImpl = ChangeResultImpl.EMPTY;
        }

        result.setChangeResult(resultImpl);
    }

    //build result for batch operation
    @SuppressWarnings("unchecked")
    public static void setMultipleEntriesResult(ChangeEntriesSpaceOperationResult result,
                                                ExtendedAnswerHolder answerHolder, int modifiers) {
        Throwable exception = answerHolder.getException();
        final boolean isDetailedResult = Modifiers.contains(modifiers, Modifiers.RETURN_DETAILED_CHANGE_RESULT);
        Collection<ChangedEntryDetails<?>> changedEntries = Collections.EMPTY_LIST;
        if (answerHolder.anyChangedEntriesForMultipleOperation() && isDetailedResult) {
            changedEntries = new ArrayList<ChangedEntryDetails<?>>(answerHolder.getModifiedEntriesData().size());
            for (int i = 0; i < answerHolder.getModifiedEntriesData().size(); i++) {
                IEntryData ed = answerHolder.getModifiedEntriesData().get(i);
                List<Object> results = answerHolder.getChangeResults() != null ? (List<Object>) answerHolder.getChangeResults().get(i) : null;
                changedEntries.add(new ChangeEntryDetailsImpl(ed.getSpaceTypeDescriptor().getTypeName(),
                        extractId(answerHolder.getModifiedEntriesUids().get(i), ed),
                        ed.getVersion(), results));
            }
        }
        Collection<FailedChangedEntryDetails> rejectedEntries = Collections.EMPTY_LIST;
        if (answerHolder.anyRejectedEntriesForMultipleOperation()) {
            rejectedEntries = new ArrayList<FailedChangedEntryDetails>(answerHolder.getRejectedEntries().size());
            for (int i = 0; i < answerHolder.getRejectedEntries().size(); i++) {
                IEntryData ed = answerHolder.getRejectedEntries().get(i);
                rejectedEntries.add(new FailedChangedEntryDetailsImpl(ed.getSpaceTypeDescriptor().getTypeName(),
                        extractId(answerHolder.getRejectedEntriesUids().get(i), ed),
                        ed.getVersion(),
                        answerHolder.getRejectedCause().get(i)));
            }
        }
        ChangeResult<?> resultImpl = null;
        if (exception != null) {
            if (isDetailedResult)
                result.setExecutionException(new ChangeException(" Failed changing entry in space  -  " + exception.getMessage(), changedEntries, rejectedEntries, Collections.singletonList(exception)));
            else
                result.setExecutionException(new ChangeException("Failed changing entry in space  - " + exception.getMessage(), answerHolder.getNumChangedEntriesForMultipleOperation(), rejectedEntries, Collections.singletonList(exception)));

        } else if (!rejectedEntries.isEmpty()) {
            if (isDetailedResult)
                result.setExecutionException(new ChangeException("Failed to change some entries in space  ", changedEntries, rejectedEntries, Collections.EMPTY_LIST));
            else
                result.setExecutionException(new ChangeException("Failed to change some entries in space  ", answerHolder.getNumChangedEntriesForMultipleOperation(), rejectedEntries, Collections.EMPTY_LIST));
        } else {
            if (answerHolder.anyChangedEntriesForMultipleOperation()) {
                if (isDetailedResult) {
                    resultImpl = new ChangeDetailedResultImpl(changedEntries);
                } else {
                    int size = answerHolder.getModifiedEntriesData().size();
                    resultImpl = size == 1 ? ChangeResultImpl.SINGLE : new ChangeResultImpl(size);
                }
            } else {
                if (isDetailedResult)
                    resultImpl = ChangeDetailedResultImpl.EMPTY;
                else
                    resultImpl = ChangeResultImpl.EMPTY;
            }
        }
        result.setChangeResult(resultImpl);
    }


    private static Object extractId(Object templateId, IEntryData entryData) {
        ITypeDesc typeDesc = entryData.getSpaceTypeDescriptor();
        List<String> idPropertiesNames = typeDesc.getIdPropertiesNames();
        if (idPropertiesNames.size() == 1) {
            Object idValue = entryData.getPropertyValue(idPropertiesNames.get(0));
            //TODO MU: (GS-10649)work around, when using auto generated id sometimes the IEntryData does not contain the id, in our case
            //the matching is by id only so we can quite safely use the template id to fill in the missing id property. However this is risky
            //and may hide other problems if for example a different entry was changed for some reason, this should be removed if we change the
            //entry data to contain the id
            if (idValue == null && typeDesc.isAutoGenerateId())
                idValue = templateId;
            return idValue;
        } else {
            return TypeDescriptorUtils.toSpaceId(idPropertiesNames, entryData::getPropertyValue);
        }
    }

    @Override
    public String getLogName(ChangeEntriesSpaceOperationRequest request, ChangeEntriesSpaceOperationResult result) {
        return "change";
    }


}
